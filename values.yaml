###
# ```{rubric} CAdvisor values
# ```
# ---
# ```{literalinclude} /values.yaml
# :language: yaml
# :start-at: "cadvisor:\n"
# :end-before: "####"
# :start-at: "# affinity:\n"
# :end-before: "###\n"
# ```
# affinity:
#   nodeAffinity:
#   requiredDuringSchedulingIgnoredDuringExecution:
#     nodeSelectorTerms:
#       - matchExpressions:
#           - key: kubernetes.io/os
#             operator: In
#             values:
#               - linux

###
# ```{rubric} Autoscaling
# ```
# ---
# Configure auto scaling on the cluster.
#
# ```{literalinclude} /values.yaml
# :caption: affinity
# :language: yaml
# :start-at: "autoscaling:\n"
# :end-before: "###\n"
# ```
#
# Thanks to [ckotzbauer](https://github.com/ckotzbauer/helm-charts)
# for the cadvisor chart!
cadvisor:
  image:
    repository: gcr.io/cadvisor/cadvisor
    tag: v0.52.1
    pullPolicy: IfNotPresent

    ## Reference to one or more secrets to be used when pulling images
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ##
    pullSecrets: []

  container:
    port: 8080
    additionalArgs:
      - --housekeeping_interval=10s # kubernetes default args
      - --max_housekeeping_interval=15s
      - --event_storage_event_limit=default=0
      - --event_storage_age_limit=default=0
      - --disable_metrics=percpu,process,sched,tcp,udp # enable only diskIO, cpu, memory, network, disk
      - --docker_only
    hostPaths:
      - name: rootfs
        path: "/"
        mount: "/rootfs"
        readOnly: true
      - name: varrun
        path: "/var/run"
        readOnly: true
      - name: sys
        path: "/sys"
        readOnly: true
      - name: docker
        path: "/var/lib/docker"
        readOnly: true
      - name: disk
        path: "/dev/disk"
        readOnly: true

  service:
    type: LoadBalancer

  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  # priorityClassName: system-cluster-critical
  priorityClassName: {}

  # sometimes errors are encountered when using the cpu load reader without being on the host network
  hostNetwork: false

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: cadvisor

  podSecurityPolicy:
    create: false
    privileged: false

  # Specifies whether a securityContext should be created. Required for privileged operations.
  podSecurityContext:
    create: false
    privileged: false

  nodeSelector: {}

  tolerations: []

  affinity: {}

  # This will create a ServiceMonitor Custom Resource indicating the prometheus operator what to scrape.
  metrics:
    enabled: false
    interval: 30s
    scrapeTimeout: 30s
    # This will allow you to specify relabelings on the metrics before ingestion. E.g. to use the kubernetes monitoring
    # mixin with this chart set metrics.enabled above to true and use:
    # relabelings:
    #  - sourceLabels:
    #    - name
    #    targetLabel: container
    #  - sourceLabels:
    #    - container_label_io_kubernetes_pod_namespace
    #    targetLabel: namespace
    #  - sourceLabels:
    #    - container_label_io_kubernetes_pod_name
    #    targetLabel: pod
    metricRelabelings: []
    # This will allow you to specify relabelings on the metrics before scraping.
    # relabelings:
    #  - action: replace
    #    sourceLabels:
    #    - __meta_kubernetes_pod_node_name
    #    targetLabel: node
    relabelings: []
####

###
# ```{rubric} monitoring Config
# ```
# ---
# Configure the monitoring deployment.
#
# ```{literalinclude} /values.yaml
# :caption: config
# :language: yaml
# :start-at: "config:\n"
# :end-before: "###\n"
# ```
config:
  allowed_hosts: "*"
  caches_backend: django_redis.cache.RedisCache
  celery:
    img:
      repository: ghcr.io/edwardtheharris/helm-monitoring/celery
      tag: "0.0.1.rc29"
    broker: "redis://redis.redis.svc.cluster.local:6379/0"
    name: celery-config
    results: "redis://redis.redis.svc.cluster.local:6379/0"
    root: "/opt/celery"
  name: monitoring-config

###
# ```{rubric} Database
# ```
# ---
# Configure a relational database connection, MySQL and PostgreSQL are
# supported.
#
# ```{literalinclude} /values.yaml
# :caption: database
# :language: yaml
# :start-at: "database:\n"
# :end-before: "###\n"
# ```
database:
  database: monitoring
  engine: django.db.backends.postgresql
  host: postgresql.postgresql.svc.cluster.local
  name: postgres
  password: ""
  port: "5432"
  secretfile: secrets/secrets.yaml
  timeout: "300"
  username: ""

###
# ```{rubric} Full Name Override
# ```
# ---
# Override the full name of the release.
#
# ```{literalinclude} /values.yaml
# :caption: fullname override
# :language: yaml
# :start-at: "fullnameOverride: \"monitoring\"\n"
# :end-before: "###\n"
# ```
fullnameOverride: "monitoring"

###
# ```{rubric} Container image settings
# ```
# ---
# Define the image, tag and repository to be deployed.
#
# ```{literalinclude} /values.yaml
# :caption: image
# :language: yaml
# :start-at: "image:\n"
# :end-before: "###\n"
# ```
image:
  pullPolicy: Always
  repository: ghcr.io/edwardtheharris/helm-monitoring/monitoring
  # Overrides the image tag whose default is the chart appVersion.
  tag: "0.0.1.rc29"
  secret:
    name: ghcr
    data: ""

###
# ```{rubric} Image Pull Secrets
# ```
# ---
# Secrets required to pull the deployment image.
#
# ```{literalinclude} /values.yaml
# :caption: imagePullSecrets
# :language: yaml
# :start-at: "imagePullSecrets:\n"
# :end-before: "###\n"
# ```
imagePullSecrets:
  - name: ghcr

###
# ```{rubric} Ingress
# ```
# ---
# Configure Ingress for the service.
#
# ```{literalinclude} /values.yaml
# :caption: ingress
# :language: yaml
# :start-at: "ingress:\n"
# :end-before: "###\n"
# ```
#
# ```{code-block} yaml
# :caption: tls example
# tls:
#  - secretName: chart-example-tls
#    hosts:
#      - chart-example.local
# ```
ingress:
  annotations:
    kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  className: "nginx"
  enabled: true
  hosts:
    - host: monitoring.svc.cluster.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []

###
# ```{rubric} Liveness Probe
# ```
# ---
# Set a command to test for liveness.
#
# ```{literalinclude} /values.yaml
# :caption: liveness probe
# :language: yaml
# :start-at: "livenessProbe:\n"
# :end-before: "###\n"
# ```
livenessProbe:
  exec:
    command:
      - /opt/monitoring/bin/monitoring-server
      - status
  # When to give up and restart the container
  failureThreshold: 3
  # Delay before the first probe is initiated
  initialDelaySeconds: 30
  # How often to perform the probe
  periodSeconds: 10
  # Minimum consecutive successes for the probe to
  # be considered successful after having failed
  successThreshold: 1
  # When the probe times out
  timeoutSeconds: 5

###
# ```{rubric} Name Override
# ```
# ---
# Override the release name, but not quite all the way.
#
# ```{literalinclude} /values.yaml
# :caption: name override
# :language: yaml
# :start-at: "nameOverride: \"monitoring\"\n"
# :end-before: "###\n"
# ```
nameOverride: "monitoring"

###
# ```{rubric} Node Selector
# ```
# ---
# Select nodes for workloads to run on.
#
# ```{literalinclude} /values.yaml
# :caption: affinity
# :language: yaml
# :start-at: "nodeSelector:\n"
# :end-before: "###\n"
# ```
nodeSelector:
  kubernetes.io/os: linux

###
# ```{rubric} Persistence Configuration
# ```
# ---
# Provision persistent storage if required.
#
# ```{literalinclude} /values.yaml
# :caption: persistence
# :language: yaml
# :start-at: "persistence:\n"
# :end-before: "###\n"
# ```
persistence:
  claim:
    enabled: true
  name: monitoring
  size: 50Gi
  storageClass: csi-driver-lvm

###
# ```{rubric} Pod Annotations
# ```
# ---
# Apply these annotations to all pods.
#
# ```{literalinclude} /values.yaml
# :caption: pod annotations
# :language: yaml
# :start-at: "podAnnotations: {}\n"
# :end-before: "###\n"
# ```
podAnnotations: {}
promtheus-node-exporter:
  enabled: true

###
# ```{rubric} Pod Labels
# ```
# ---
# Apply these labels to all pods.
#
# ```{literalinclude} /values.yaml
# :caption: pod labels
# :language: yaml
# :start-at: "podLabels:\n"
# :end-before: "###\n"
# ```
podLabels:
  app: monitoring

###
# ```{rubric} Pod Security Context
# ```
# ---
# Define security context for pods.
#
# ```{literalinclude} /values.yaml
# :caption: pod security context
# :language: yaml
# :start-at: "podSecurityContext: {}\n"
# :end-before: "###\n"
# ```
#
# ```{code-block} yaml
# :caption: pod security context EXAMPLE
#
# podSecurityContext:
#  fsGroup: 1000
# ```
podSecurityContext: {}

###
# ```{rubric} Replica Count
# ```
# ---
# Deploy this many replicas by default.
#
# ```{literalinclude} /values.yaml
# :caption: replicas
# :language: yaml
# :start-at: "replicaCount: 1\n"
# :end-before: "###\n"
# ```
# readinessProbe:
#   exec:
#     command:
#     - pg_isready
#     - -U
#     - postgres
#   failureThreshold: 3 # When to give up, marking the Pod as Unready
#   initialDelaySeconds: 5 # Delay before the first probe is initiated, can be shorter than liveness probe
#   periodSeconds: 5 # How often to perform the probe
#   successThreshold: 1 # Minimum consecutive successes for the probe to be considered successful
#   timeoutSeconds: 1 # When the probe times out
replicaCount: 1

###
# ```{rubric} Resource Requests and Limits
# ```
# ---
# Set requests and limits for workload resources.
#
# ```{literalinclude} /values.yaml
# :caption: resources
# :language: yaml
# :start-at: "resources:\n"
# :end-before: "###\n"
# ```
#
# We usually recommend not to specify default resources and to leave this as
# a conscious choice for the user. This also increases chances charts run on
# environments with little resources, such as Minikube. If you do want to
# specify resources, uncomment the following lines, adjust them as necessary,
# and remove the curly braces after `resources:`{l=yaml}.
#
# ```{code-block} yaml
# :caption: resources example
#
# limits:
#   cpu: 100m
#   memory: 128Mi
# requests:
#   cpu: 100m
#   memory: 128Mi
# ```
resources:
  limits:
    cpu: 2
    memory: 4096Mi

###
# ```{rubric} Security Context
# ```
# ---
# Set a security context on the workloads.
#
# ```{literalinclude} /values.yaml
# :caption: securityContext
# :language: yaml
# :start-at: "securityContext: {}\n"
# :end-before: "###\n"
# ```
securityContext: {}

###
# ```{rubric} Service
# ```
# ---
# Define the service used to access the application.
#
# ```{literalinclude} /values.yaml
# :caption: service
# :language: yaml
# :start-at: "service:\n"
# :end-before: "###\n"
# ```
#
# ```{code-block} yaml
# :caption: capabilities example
# capabilities:
#   drop:
#   - ALL
# readOnlyRootFilesystem: true
# runAsNonRoot: true
# runAsUser: 1000
# ```
service:
  enabled: true
  port: 8000
  targetPort: 8000
  type: LoadBalancer
  selectorLabels:
    app.kubernetes.io/component: network
    app.kubernetes.io/name: monitoring

###
# ```{rubric} Service Account
# ```
# ---
# When enabled, will create a Kubernetes Service Account during deployment.
#
# ```{literalinclude} /values.yaml
# :caption: serviceAccount
# :language: yaml
# :start-at: "serviceAccount:\n"
# :end-before: "###\n"
# ```
serviceAccount:
  # Annotations to add to the service account
  annotations:
    sa.kubernetes.io/name: monitoring
  # Automatically mount a ServiceAccount's API credentials?
  automount: true
  # Specifies whether a service account should be created
  create: true
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: "monitoring"

###
# ```{rubric} Tolerations
# ```
# ---
# Define taints that will be tolerated to run workloads on nodes.
#
# ```{literalinclude} /values.yaml
# :caption: tolerations
# :language: yaml
# :start-at: "tolerations: []\n"
# :end-before: "###\n"
# ```
tolerations: []

###
# ```{rubric} Type
# ```
# ---
# May be set to `Deployment` or `StatefulSet`.
#
# ```{literalinclude} /values.yaml
# :caption: type
# :language: yaml
# :start-at: "type: Deployment\n"
# :end-before: "###\n"
# ```
type: StatefulSet

###
# ```{rubric} Volume Mounts
# ```
# ---
# Additional volumeMounts on the output Deployment definition.
#
# ```{literalinclude} /values.yaml
# :caption: volume mounts
# :language: yaml
# :start-at: "volumeMounts: []\n"
# :end-before: "###\n"
# ```
#
# ```{code-block} yaml
# :caption: volumeMounts example
# - mountPath: "/mnt/k8s/psql"
#   name: data
#   readOnly: false
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true
# ```
volumeMounts: []

###
# ```{rubric} Volumes
# ```
# ---
# Additional volumes on the output Deployment definition.
#
# ```{literalinclude} /values.yaml
# :caption: volumes
# :language: yaml
# :start-at: "volumes: []\n"
# ```
#
# ```{code-block} yaml
# :caption: volume example
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false
# ```
volumes: []
